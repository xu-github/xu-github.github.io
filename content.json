{"meta":{"title":"秀秀专属","subtitle":"秀秀的git博客","description":"乐观开朗勤奋好学的女孩纸","author":"徐秀芳","url":"https://xu-github.github.io"},"pages":[{"title":"","date":"2019-04-02T11:10:01.448Z","updated":"2019-04-02T11:10:01.447Z","comments":true,"path":"404.html","permalink":"https://xu-github.github.io/404.html","excerpt":"","text":"公益404页面 // 曹淼的\"git博客\""},{"title":"分类","date":"2016-01-29T13:13:21.000Z","updated":"2019-04-02T11:10:01.554Z","comments":false,"path":"categories/index.html","permalink":"https://xu-github.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2016-02-01T10:29:36.000Z","updated":"2019-04-02T11:10:01.552Z","comments":false,"path":"tags/index.html","permalink":"https://xu-github.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于本人","date":"2017-10-01T10:29:36.000Z","updated":"2019-04-03T14:24:00.855Z","comments":false,"path":"about/index.html","permalink":"https://xu-github.github.io/about/index.html","excerpt":"","text":"资深java工程师 资深.net工程师 对开源软件感兴趣 来自河北 现居北京 邮箱: 624428656@qq.com QQ: 624428656 此博客基于hexo开发，通过markdown语法写作。"}],"posts":[{"title":"【转】linq相关","slug":"linq","date":"2019-02-01T02:30:16.000Z","updated":"2019-04-03T12:13:37.781Z","comments":true,"path":"2019/02/01/linq/","link":"","permalink":"https://xu-github.github.io/2019/02/01/linq/","excerpt":"","text":"查询主体中的from…let…where片段 可选的from…let…where部分是查询主体的第一部分，可以由任意数量的3个子句来组合–from子句、let子句和where子句。 from子句 查询表达式从必需的from子句开始，后面跟查询主体。主体本身可以从任何数量的其他from子句开始，每个from子句都指定了一个额外的源数据集合并引入了要在之后运算的迭代变量，所有from子句的语法和含义都一样。 例：from子句示例 12345678910111213141516class Program&#123; static void Main() &#123; var groupA=new[]&#123;3,4,5,6&#125;; var groupA=new[]&#123;6,7,8,9&#125;; var someInts=from a in groupA from b in groupB where a&gt;4&amp;&amp;b&lt;=8 select new&#123;a,b,sum=a+b&#125;;//匿名类型对象 foreach(var a in someInts) &#123; Console.WriteLine(a); &#125; &#125;&#125; let子句 let子句接受一个表达式的运算并且把它赋值给一个需要在其他运算中使用的标识符。let子句的语法如下： 1let Identifier=Expression 例：let子句示例 1234567891011121314151617class Program&#123; static void Main() &#123; var groupA=new[]&#123;3,4,5,6&#125;; var groupA=new[]&#123;6,7,8,9&#125;; var someInts=from a in groupA from b in groupB let sum=a+b //在新的变量中保存结果 where sum==12 select new&#123;a,b,sum&#125;; foreach(var a in someInts) &#123; Console.WriteLine(a); &#125; &#125;&#125; where子句 where子句根据之后的运算来筛选指定项。只要是在from…let…where部分中，查询表达式可以有多个where。 例：where子句示例 123456789101112131415161718class Program&#123; static void Main() &#123; var groupA=new[]&#123;3,4,5,6&#125;; var groupA=new[]&#123;6,7,8,9&#125;; var someInts=from a in groupA from b in groupB let sum=a+b where sum&gt;=11 ←条件1 where a==4 ←条件2 select new&#123;a,b,sum&#125;; foreach(var a in someInts) &#123; Console.WriteLine(a); &#125; &#125;&#125; orderby子句 orderby子句根据表达式按顺序返回结果项。orderby子句语法如下图。可选的ascending和descending关键字设置了排序方向。表达式通常是项的一个字段。该字段不一定非得是数值字段，也可以是字符串这样的可排序类型。 例：按照学生年龄排序 12345678910111213141516171819class Program&#123; static void Main() &#123; var students=new[] &#123; new&#123;LName=&quot;Jones&quot;,FName=&quot;Mary&quot;,Age=19,Major=&quot;History&quot;&#125;, new&#123;LName=&quot;Smith&quot;,FName=&quot;Bob&quot;,Age=20,Major=&quot;CompSci&quot;&#125;, new&#123;LName=&quot;Fleming&quot;,FName=&quot;Carol&quot;,Age=21,Major=&quot;History&quot;&#125;, &#125;; var query=from student in students orderby student.Age select student; foreach(var s in query) &#123; Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;: &#123;2&#125; - &#123;3&#125;&quot;,s.LName,s.FName,s.Age,s.Major); &#125; &#125;&#125; group子句 group子句把select的对象根据一些标准进行分组。例如，之前示例的学士数组，程序可以根据它们的主修课程进行分组。 如果项包含在查询的结果中，它们就可以根据某个字段的值进行分组。作为分组依据的属性叫做键（key） group子句返回的不是原始数据源中项的枚举，而是返回可以枚举已经形成的项的分组的可枚举类型 分组本身是可枚举类型，它们可以枚举实际的项 例：根据学士的主修课程进行分组 123456789101112131415161718192021222324using System;using System.Linq;class Program&#123; static void Main() &#123; var students=new[] &#123; new&#123;LName=&quot;Jones&quot;,FName=&quot;Mary&quot;,Age=19,Major=&quot;History&quot;&#125;, new&#123;LName=&quot;Smith&quot;,FName=&quot;Bob&quot;,Age=20,Major=&quot;CompSci&quot;&#125;, new&#123;LName=&quot;Fleming&quot;,FName=&quot;Carol&quot;,Age=21,Major=&quot;History&quot;&#125;, &#125;; var query=from s in students group s by s.Major; foreach(var s in query) &#123; Console.WriteLine(&quot;&#123;0&#125;&quot;,s.Key); foreach(var t in s) &#123; Console.WriteLine(&quot; &#123;0&#125;,&#123;1&#125;&quot;,t.LName,t.FName); &#125; &#125; &#125;&#125; 查询延续：into子句 查询延续子句可以接受查询的一部分结果并赋予一个名字，从而可以在查询的另一部分中使用。 例：连接groupA和groupB并命名为groupAandB 1234567891011121314151617class Program&#123; static void Main() &#123; var groupA=new[]&#123;3,4,5,6&#125;; var groupA=new[]&#123;6,7,8,9&#125;; var someInts=from a in groupA join b in groupB on a equals b into groupAandB from c in groupAandB select c; foreach(var a in someInts) &#123; Console.WriteLine(a); &#125; &#125;&#125; 标准查询运算符 标准查询运算符由一系列API方法组成，它能让我们查询任何.NET数组或集合。标准查询运算符的重要特性如下： 被查询的集合对象叫做序列，它必须实现IEnumerable&lt;T&gt;接口，T是类型 标准查询运算符使用方法语法 一些运算符返回IEnumerable对象（或其他序列），而其他的一些运算符返回标量。返回标量的运算符立即执行，并返回一个值 很多操作都以一个谓词作为参数。谓词是一个方法，它以对象为参数，根据对象是否满足某条件而返回true或false 例：Sum和Count运算符的使用 12345678910class Program&#123; static int[] numbers=new int[]&#123;2,4,6&#125;; static void Main() &#123; int total=numbers.Sum(); int howMany=number.Count(); Console.WriteLine(&quot;Total: &#123;0&#125;,Count: &#123;1&#125;&quot;,total,howMany); &#125;&#125; 转自：http://www.cnblogs.com/moonache/p/6552843.html","categories":[{"name":".net","slug":"net","permalink":"https://xu-github.github.io/categories/net/"}],"tags":[{"name":"linq","slug":"linq","permalink":"https://xu-github.github.io/tags/linq/"},{"name":"sql","slug":"sql","permalink":"https://xu-github.github.io/tags/sql/"},{"name":"db","slug":"db","permalink":"https://xu-github.github.io/tags/db/"},{"name":".net","slug":"net","permalink":"https://xu-github.github.io/tags/net/"}]},{"title":"【原创】SDK与 IDE等名词解释","slug":"SDK&IDE","date":"2019-01-25T09:00:16.000Z","updated":"2019-04-03T12:12:37.661Z","comments":true,"path":"2019/01/25/SDK&IDE/","link":"","permalink":"https://xu-github.github.io/2019/01/25/SDK&IDE/","excerpt":"","text":"全称 Software Development Kit ,软件开发工具包。IDE：全称 Integrated Development，集成开发环境。SDK是一个能够进行开发的环境，是一个基本的环境，可以添加一些其他的功能，添加插件帮助实现想要的功能。这种将想要的插件安装在SDK上的环境称为IDE","categories":[{"name":"名词解释","slug":"名词解释","permalink":"https://xu-github.github.io/categories/名词解释/"}],"tags":[{"name":"SDK","slug":"SDK","permalink":"https://xu-github.github.io/tags/SDK/"},{"name":"IDE","slug":"IDE","permalink":"https://xu-github.github.io/tags/IDE/"}]},{"title":"【原创】BigDecimal判断两值是否相等","slug":"BigDecimal","date":"2018-12-11T09:10:16.000Z","updated":"2019-04-03T12:48:52.748Z","comments":true,"path":"2018/12/11/BigDecimal/","link":"","permalink":"https://xu-github.github.io/2018/12/11/BigDecimal/","excerpt":"","text":"1、用compareTo方法 用compareTo方法来判断BigDecimal两值是否相等，判断结果为0则相等，否则不等，如下： if(amt == null|| amt.compareTo(BigDecimal.ZERO)==0){} 2、不能用== 因为BigDecimal不是基本类型，它只是把你的数值（基本类型）封装到了intCompact（Long类型）这个属性中，是对象类型，==只能比较基本类型。 3、不能用equals方法 equals方法被BigDecimal重写了，源码如下123456789101112131415161718192021@Override public boolean equals(Object x) &#123; if (!(x instanceof BigDecimal)) return false; BigDecimal xDec = (BigDecimal) x; if (x == this) return true; if (scale != xDec.scale) return false; long s = this.intCompact; long xs = xDec.intCompact; if (s != INFLATED) &#123; if (xs == INFLATED) xs = compactValFor(xDec.intVal); return xs == s; &#125; else if (xs != INFLATED) return xs == compactValFor(this.intVal); return this.inflated().equals(xDec.inflated());&#125; 从上面代码中，其中有一个判断scale 值是否相等的过程，scale 这个值是BigDecimal的私有属性，表示BigDecimal小数点位数，所以equals判断两个值是否相等，会先判断这两个数值是否小数点位数是否相等，然后在判断大小是否相等。","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"https://xu-github.github.io/tags/BigDecimal/"}]},{"title":"【原创】ireport主子报表传参问题","slug":"ireport","date":"2018-12-11T02:17:16.000Z","updated":"2019-04-03T12:53:30.816Z","comments":true,"path":"2018/12/11/ireport/","link":"","permalink":"https://xu-github.github.io/2018/12/11/ireport/","excerpt":"","text":"主子报表相关几个问题小结，选中子报表，在属性中看到上图 1、子报表向主报表传参，在Return Values配置 2、主报表向子报表传参，在Parameters中配置 3、Data Source Expression中配置主报表向子报表传要显示的数据源，subData为数据集名称 new net.sf.jasperreports.engine.data.JRBeanCollectionDataSource($F{subData})","categories":[{"name":"ireport","slug":"ireport","permalink":"https://xu-github.github.io/categories/ireport/"}],"tags":[{"name":"ireport","slug":"ireport","permalink":"https://xu-github.github.io/tags/ireport/"},{"name":"报表","slug":"报表","permalink":"https://xu-github.github.io/tags/报表/"}]},{"title":"【原创】删除 List 元素的几种方法","slug":"delete-javalist","date":"2018-09-25T07:04:16.000Z","updated":"2019-04-03T12:25:36.581Z","comments":true,"path":"2018/09/25/delete-javalist/","link":"","permalink":"https://xu-github.github.io/2018/09/25/delete-javalist/","excerpt":"","text":"删除 List 中的元素会产生两个问题：1、删除元素后 List 的元素数量会发生变化； 2、对 List 进行删除操作可能会产生并发问题； 现总结出五种可行方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package com.xxx.list;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class ArrayListRemove &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"bbb\"); list.add(\"ccc\"); list.add(\"ddd\"); remove1(list, \"bbb\"); &#125; private static void print(List&lt;String&gt; list)&#123; for (String item : list) &#123; System.out.println(\"列表值：\" + item); &#125; &#125; /* * 错误 * java.lang.IndexOutOfBoundsException * 由于int size = list.size();提前获取了 List 的大小，for 循环中删除了两个元素，导致出现数组越界问题。 */ public static void remove11(List&lt;String&gt; list, String target)&#123; int size = list.size(); for(int i = 0; i &lt; size; i++)&#123; String item = list.get(i); if(target.equals(item))&#123; list.remove(item); &#125; &#125; print(list); &#125; /* * 错误 *该方法解决了数组越界问题，但没有解决彻底删除数据的问题。List 删除元素的逻辑是将目标元素之后的元素往前移一个索引位置，最后一个元素置为 null，同时 size - 1；这也就解释了为什么第二个“bbb”没有被删除。 */ public static void remove12(List&lt;String&gt; list, String target)&#123; for(int i = 0; i &lt; list.size(); i++)&#123; String item = list.get(i); if(target.equals(item))&#123; list.remove(item); &#125; &#125; print(list); &#125; /* * 正确 */ public static void remove13(List&lt;String&gt; list, String target)&#123; int size = list.size(); for(int i = size - 1; i &gt;= 0; i--)&#123; String item = list.get(i); if(target.equals(item))&#123; list.remove(item); &#125; &#125; print(list); &#125; /* * 正确 *remove13 与 remove14没有区别，但是 remove11 与 remove12 有区别，remove12 中每次for(int i = 0; i &lt; list.size(); i++)执行都会计算 size 值，比较耗性能。 */ public static void remove14(List&lt;String&gt; list, String target)&#123; for(int i = list.size() - 1; i &gt;= 0; i--)&#123; String item = list.get(i); if(target.equals(item))&#123; list.remove(item); &#125; &#125; print(list); &#125; /* * 错误 *java.lang.IndexOutOfBoundsException */ public static void remove15(List&lt;String&gt; list, String target)&#123; int size = list.size(); for(int i = 0; i &lt; size; i++)&#123; String item = list.get(i); if(target.equals(item))&#123; list.remove(item--); &#125; &#125; print(list); &#125; /* * 正确 * List 删除元素的逻辑是将目标元素之后的元素往前移一个索引位置，先删除i减一向前移一位 */ public static void remove16(List&lt;String&gt; list, String target)&#123; for(int i = 0; i &lt; list.size(); i++)&#123; String item = list.get(i); if(target.equals(item))&#123; list.remove(item--); &#125; &#125; print(list); &#125; /* * 错误 底层为Iterator */ public static void remove21(List&lt;String&gt; list, String target)&#123; for(String item : list)&#123; if(target.equals(item))&#123; list.remove(item); &#125; &#125; print(list); &#125; /* * 正确 */ public static void remove22(ArrayList&lt;String&gt; list, String target) &#123; final CopyOnWriteArrayList&lt;String&gt; cowList = new CopyOnWriteArrayList&lt;String&gt;(list); for (String item : cowList) &#123; if (item.equals(target)) &#123; cowList.remove(item); &#125; &#125; print(cowList); &#125; /* * 错误 */ public static void remove31(List&lt;String&gt; list, String target)&#123; Iterator&lt;String&gt; iter = list.iterator(); while (iter.hasNext()) &#123; String item = iter.next(); if (item.equals(target)) &#123; list.remove(item); &#125; &#125; print(list); &#125; /* * 正确 */ public static void remove32(List&lt;String&gt; list, String target)&#123; Iterator&lt;String&gt; iter = list.iterator(); while (iter.hasNext()) &#123; String item = iter.next(); if (item.equals(target)) &#123; iter.remove(); &#125; &#125; print(list); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"List","slug":"List","permalink":"https://xu-github.github.io/tags/List/"}]},{"title":"【转载】Eclipse快捷键 10个最有用的快捷键","slug":"Eclipse-keymap","date":"2018-09-19T03:22:16.000Z","updated":"2019-04-03T12:48:15.786Z","comments":true,"path":"2018/09/19/Eclipse-keymap/","link":"","permalink":"https://xu-github.github.io/2018/09/19/Eclipse-keymap/","excerpt":"","text":"Eclipse中10个最有用的快捷键组合 一个Eclipse骨灰级开发者总结了他认为最有用但又不太为人所知的快捷键组合。通过这些组合可以更加容易的浏览源代码，使得整体的开发效率和质量得到提升。 ​ 1. ctrl+shift+r：打开资源 ​ 这可能是所有快捷键组合中最省时间的了。这组快捷键可以让你打开你的工作区中任何一个文件，而你只需要按下文件名或mask名中的前几个字母，比如applic*.xml。美中不足的是这组快捷键并非在所有视图下都能用。 2. ctrl+o：快速outline ​ 如果想要查看当前类的方法或某个特定方法，但又不想把代码拉上拉下，也不想使用查找功能的话，就用ctrl+o吧。它可以列出当前类中的所有方法及属性，你只需输入你想要查询的方法名，点击enter就能够直接跳转至你想去的位置。 3. ctrl+e：快速转换编辑器 ​ 这组快捷键将帮助你在打开的编辑器之间浏览。使用ctrl+page down或ctrl+page up可以浏览前后的选项卡，但是在很多文件打开的状态下，ctrl+e会更加有效率。 4. ctrl+2，L：为本地变量赋值 ​ 开发过程中，我常常先编写方法，如Calendar.getInstance()，然后通过ctrl+2快捷键将方法的计算结果赋值于一个本地变量之上。 这样我节省了输入类名，变量名以及导入声明的时间。Ctrl+F的效果类似，不过效果是把方法的计算结果赋值于类中的域。 ​ 5. alt+shift+r：重命名 ​ 重命名属性及方法在几年前还是个很麻烦的事，需要大量使用搜索及替换，以至于代码变得零零散散的。今天的Java IDE提供源码处理功能，Eclipse也是一样。现在，变量和方法的重命名变得十分简单，你会习惯于在每次出现更好替代名称的时候都做一次重命名。要使 用这个功能，将鼠标移动至属性名或方法名上，按下alt+shift+r，输入新名称并点击回车。就此完成。如果你重命名的是类中的一个属性，你可以点击alt+shift+r两次，这会呼叫出源码处理对话框，可以实现get及set方法的自动重命名。 ​ 6. alt+shift+l以及alt+shift+m：提取本地变量及方法 ​ 源码处理还包括从大块的代码中提取变量和方法的功能。比如，要从一个string创建一个常量，那么就选定文本并按下alt+shift+l即可。如果同 一个string在同一类中的别处出现，它会被自动替换。方法提取也是个非常方便的功能。将大方法分解成较小的、充分定义的方法会极大的减少复杂度，并提 升代码的可测试性。 ​ 7. shift+enter及ctrl+shift+enter ​ Shift+enter在当前行之下创建一个空白行，与光标是否在行末无关。Ctrl+shift+enter则在当前行之前插入空白行。 ​ 8. Alt+方向键 ​ 这也是个节省时间的法宝。这个组合将当前行的内容往上或下移动。在try/catch部分，这个快捷方式尤其好使。 ​ 9. ctrl+m ​ 大显示屏幕能够提高工作效率是大家都知道的。Ctrl+m是编辑器窗口最大化的快捷键。 ​ 10. ctrl+.及ctrl+1：下一个错误及快速修改 ​ ctrl+.将光标移动至当前文件中的下一个报错处或警告处。这组快捷键我一般与ctrl+1一并使用，即修改建议的快捷键。新版Eclipse的修改建 议做的很不错，可以帮你解决很多问题，如方法中的缺失参数，throw/catch exception，未执行的方法等等。 更多快捷键组合可在Eclipse按下ctrl+shift+L查看。 让我们按照使用频率来看看我最爱用的一些热键组合。（注：以下内容在Eclipse3.02及一上版本通过测试） \\1. Control-Shift-T: 打开类型（Open type）。如果你不是有意磨洋工，还是忘记通过源码树（source tree）打开的方式吧。用eclipse很容易打开接口的实现类的，按ctrl+t会列出接口的实现类列表 \\2. Control-Shift-R: 打开资源（不只是用来寻找Java文件）。小提示：利用Navigator视图的黄色双向箭头按钮让你的编辑窗口和导航器相关联。这会让你打开的文件对应显示在导航器的层级结构中，这样便于组织信息。如果这影响了速度，就关掉它。 \\3. F3: 打开申明（Open declaration）。或者，利用Declaration Tab（在Java视图模式下，选择Windows –&gt; Show View – &gt; Declaration）。当你选中代码中的一个方法，然后按这个按键，它会把整个方法在申明方框里显示出来。 \\4. Alt-left arrow: 在导航历史记录（Navigation History）中后退。就像Web浏览器的后退按钮一样，在利用F3跳转之后，特别有用。（用来返回原先编译的地方） \\5. Alt-right arrow: 导航历史记录中向前。 \\6. Control-Q: 回到最后一次编辑的地方。这个快捷键也是当你在代码中跳转后用的。特别是当你钻的过深，忘记你最初在做什么的时候。 \\7. Control-Shift-G: 在workspace中搜索引用（reference）。这 是重构的前提。对于方法，这个热键的作用和F3恰好相反。它使你在方法的栈中，向上找出一个方法的所有调用者。一个与此相关的功能是开启“标记”功能 （occurrence marking） 。选择Windows-&gt;Preferences-&gt;Java-&gt; Editor-&gt; Mark Occurrences，勾选选项。这时，当你单击一个元素的时候，代码中所有该元素存在的地方都会被高亮显示。我个人只使用“标记本地变量”（Mark Local Variables）。注意：太多的高亮显示会拖慢Eclipse。 \\8. Control-Shift-F: CodeàJavaàPreferencesà根据代码风格设定重新格式化代码。我 们的团队有统一的代码格式，我们把它放在我们的wiki上。要这么做，我们打开Eclipse，选择Window Style，然后设置Code Formatter，Code Style和Organize Imports。利用导出（Export）功能来生成配置文件。我们把这些配置文件放在wiki上，然后团队里的每个人都导入到自己的Eclipse中。 \\9. Control-O: 快速概要(quick outline)。通过这个快捷键，你可以迅速的跳到一个方法或者属性，只需要输入名字的头几个字母。 \\10. Control-/: 对一行注释或取消注释。对于多行也同样适用。 \\11. Control-Alt-down arrow: 复制高亮显示的一行或多行。 \\12. Alt-down arrow: 将一行或多行向下移动。Alt-up arrow会向上移动。 其他的热键在菜单里有。你可以通过按下Control-Shift-L（从3.1版本开始）， 看到所有快捷键的列表。按下Control-Shift-L两次，会显示热键对话框（Keys Preferences dialog），你可以在这里自己设置热键。我欢迎你在Talkback部分发表你的Eclipse提示。 其他的Eclipse窍门 我总结了几个相关的小窍门： 锁定命令行窗口：在命令行视图中（Window -&gt;Show View -&gt;Other -&gt;Basic -&gt;Console），试试看用滚动锁定按钮来锁定控制台输出不要滚屏。 使用Ant视图： 在我的Java或Debug模式下，我喜欢显示出Ant视图，这样我就可以迅速的运行Ant任务。通过Window Ant可以找到该视图。把Ant视图放在屏幕的一角， 通过“添加编译文件（Addà Other à Show View à Buildfiles）”按钮来添加build.xml文件。在3.1版本中，甚至支持Ant调试脚本语言。 自动遍历一个集合：for + Control-Space: 如果你还不知道，那么你应该记住Control-Space是自动完成功能。在Eclipse中，你还可以自动完成结构。在一个数组或集合范围内，试试看 输入“for”然后按下Control-Space键。Eclipse会问你你想要遍历哪一个集合然后自动完成循环代码。 使用分级布局： 在包浏览视图（Package Explorer view）中默认的布局（扁平式）方式让我困惑，它把包的全名显示在导航树（navigation tree）中。我更喜欢我源码的包和文件系统视图，在Eclipse中叫做分级布局（Hierarchical Layout）。要切换到这种模式，点击包浏览视图中向下的按钮，选择布局（Layout），然后选择分级（Hierarchial）。 一次显示多个文件：你可以一次浏览多个文件。把不在激活状态的编辑窗口拖到激活窗口的底部或侧边的滚动条上，就可以打开该编辑窗口。这是我能描述该窍门的最好方式了。 同时打开两个Eclipse： 要将改动从一个CVS分支上合并到另外一个上，我喜欢通过同时打开两个工作目录（Workspace）不同Eclipse来实现。这样我可以通过比较 CVS上的最新版本看到所有的变化（右键单击工程，然后选择Compare Lastest from HEAD）然后把每一个变化都合并到另外一个CVS分支上。启动多个Eclipse的最简单的方法是利用Eclipseàwith Launcher。 Implementors插件：安装一个能够跳到一个接口的实现的插件。如果你是个dependency injection 粉丝，或者正在基于编写优良的接口工作，那么你需要一个这样的插件来加速代码导航。 你可以在SourceForge找到这个插件。 Ctrl+Alt+H 如果你想知道一个类的方法到底被那些其他的类调用，那么请选中这个方法名，然后按“Ctrl+Alt+H”， Eclipse就会显示出这个方法被哪些方法调用，最终产生一个调用关系树。\\1. Ctrl+左键 这个是大多数人经常用到的，用来查看变量、方法、类的定义 \\2. Ctrl+O 查看一个类的纲要，列出其方法和成员变量。提示：再多按一次Ctrl+O，可以列出该类继承的方法和变量。 助记：”O”—&gt;”Outline”—&gt;”纲要” \\3. Ctrl+T 查看一个类的继承关系树，是自顶向下的，再多按一次Ctrl+T, 会换成自底向上的显示结构。 提示：选中一个方法名，按Ctrl+T，可以查看到有这个同名方法的父类、子类、接口。 助记：”T”——-&gt;”Tree”—–&gt;”层次树” 4.Alt+左右方向键 我们经常会遇到看代码时Ctrl+左键，层层跟踪，然后迷失在代码中的情况，这时只需要按“Alt+左方向键 ”就可以退回到上次阅读的位置，同理，按“Alt+右方向键”会前进到刚才退回的阅读位置，就像浏览器的 前进和后退按钮一样。 导入包：Ctrl+Shift+O编辑作用域 功能 快捷键全局 查找并替换 Ctrl+F文本编辑器 查找上一个 Ctrl+Shift+K文本编辑器 查找下一个 Ctrl+K全局 撤销 Ctrl+Z全局 复制 Ctrl+C全局 恢复上一个选择 Alt+Shift+↓全局 剪切 Ctrl+X全局 快速修正 Ctrl1+1全局 内容辅助 Alt+/全局 全部选中 Ctrl+A全局 删除 Delete全局 上下文信息 Alt+？Alt+Shift+?Ctrl+Shift+SpaceJava编辑器 显示工具提示描述 F2Java编辑器 选择封装元素 Alt+Shift+↑Java编辑器 选择上一个元素 Alt+Shift+←Java编辑器 选择下一个元素 Alt+Shift+→文本编辑器 增量查找 Ctrl+J文本编辑器 增量逆向查找 Ctrl+Shift+J全局 粘贴 Ctrl+V全局 重做 Ctrl+Y查看作用域 功能 快捷键全局 放大 Ctrl+=全局 缩小 Ctrl+-窗口作用域 功能 快捷键全局 激活编辑器 F12全局 切换编辑器 Ctrl+Shift+W全局 上一个编辑器 Ctrl+Shift+F6全局 上一个视图 Ctrl+Shift+F7全局 上一个透视图 Ctrl+Shift+F8全局 下一个编辑器 Ctrl+F6全局 下一个视图 Ctrl+F7全局 下一个透视图 Ctrl+F8文本编辑器 显示标尺上下文菜单 Ctrl+W全局 显示视图菜单 Ctrl+F10全局 显示系统菜单 Alt+-导航作用域 功能 快捷键Java编辑器 打开结构 Ctrl+F3全局 打开类型 Ctrl+Shift+T全局 打开类型层次结构 F4全局 打开声明 F3全局 打开外部javadoc Shift+F2全局 打开资源 Ctrl+Shift+R全局 后退历史记录 Alt+←全局 前进历史记录 Alt+→全局 上一个 Ctrl+,全局 下一个 Ctrl+.Java编辑器 显示大纲 Ctrl+O全局 在层次结构中打开类型 Ctrl+Shift+H全局 转至匹配的括号 Ctrl+Shift+P全局 转至上一个编辑位置 Ctrl+QJava编辑器 转至上一个成员 Ctrl+Shift+↑Java编辑器 转至下一个成员 Ctrl+Shift+↓文本编辑器 转至行 Ctrl+L搜索作用域 功能 快捷键全局 出现在文件中 Ctrl+Shift+U全局 打开搜索对话框 Ctrl+H全局 工作区中的声明 Ctrl+G全局 工作区中的引用 Ctrl+Shift+G文本编辑作用域 功能 快捷键文本编辑器 改写切换 Insert文本编辑器 上滚行 Ctrl+↑文本编辑器 下滚行 Ctrl+↓文件作用域 功能 快捷键全局 保存 Ctrl+XCtrl+S全局 打印 Ctrl+P全局 关闭 Ctrl+F4全局 全部保存 Ctrl+Shift+S全局 全部关闭 Ctrl+Shift+F4全局 属性 Alt+Enter全局 新建 Ctrl+N项目作用域 功能 快捷键全局 全部构建 Ctrl+B源代码作用域 功能 快捷键Java编辑器 格式化 Ctrl+Shift+FJava编辑器 取消注释 Ctrl+/Java编辑器 注释 Ctrl+/Java编辑器 添加单个import Ctrl+Shift+MJava编辑器 组织多个import Ctrl+Shift+OJava编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。也可以使用Ctrl+1自动修正。调试/运行作用域 功能 快捷键全局 单步返回 F7全局 单步跳过 F6全局 单步跳入 F5全局 单步跳入选择 Ctrl+F5全局 调试上次启动 F11全局 继续 F8全局 使用过滤器单步执行 Shift+F5全局 添加/去除断点 Ctrl+Shift+B全局 显示 Ctrl+D全局 运行上次启动 Ctrl+F11全局 运行至行 Ctrl+R全局 执行 Ctrl+U重构作用域 功能 快捷键全局 撤销重构 Alt+Shift+Z全局 抽取方法 Alt+Shift+M全局 抽取局部变量 Alt+Shift+L全局 内联 Alt+Shift+I全局 移动 Alt+Shift+V全局 重命名 Alt+Shift+R全局 重做 Alt+Shift+Y （1）Ctrl+M切换窗口的大小（2）Ctrl+Q跳到最后一次的编辑处（3）F2当鼠标放在一个标记处出现Tooltip时候按F2则把鼠标移开时Tooltip还会显示即Show Tooltip Description。F3跳到声明或定义的地方。F5单步调试进入函数内部。F6单步调试不进入函数内部，如果装了金山词霸2006则要把“取词开关”的快捷键改成其他的。F7由函数内部返回到调用处。F8一直执行到下一个断点。（4）Ctrl+Pg~对于XML文件是切换代码和图示窗口（5）Ctrl+Alt+I看Java文件中变量的相关信息（6）Ctrl+PgUp对于代码窗口是打开“Show List”下拉框，在此下拉框里显示有最近曾打开的文件（7）Ctrl+/ 在代码窗口中是这种//~注释。Ctrl+Shift+/ 在代码窗口中是这种/~/注释，在JSP文件窗口中是〈!–~–〉。（8）Alt+Shift+O(或点击工具栏中的Toggle Mark Occurrences按钮) 当点击某个标记时可使本页面中其他 地方的此标记黄色凸显，并且窗口的右边框会出现白色的方块，点击此方块会跳到此标记处。（9）右击窗口的左边框即加断点的地方选Show Line Numbers可以加行号。（10）Ctrl+I格式化激活的元素Format Active Elements。Ctrl+Shift+F格式化文件Format Document。（11）Ctrl+S保存当前文件。Ctrl+Shift+S保存所有未保存的文件。（12）Ctrl+Shift+M(先把光标放在需导入包的类名上) 作用是加Import语句。Ctrl+Shift+O作用是缺少的Import语句被加入，多余的Import语句被删除。（13）Ctrl+Space提示键入内容即Content Assist，此时要将输入法中Chinese(Simplified)IME- Ime/Nonlme Toggle的快捷键（用于切换英文和其他文字）改成其他的。Ctrl+Shift+Space提示信息即Context Information。（14）双击窗口的左边框可以加断点。（15）Ctrl+D删除当前行。 Eclipse快捷键大全Ctrl+1 快速修复(最经典的快捷键,就不用多说了)Ctrl+D: 删除当前行Ctrl+Alt+↓ 复制当前行到下一行(复制增加)Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)Alt+↑ 当前行和上面一行交互位置(同上)Alt+← 前一个编辑的页面Alt+→ 下一个编辑的页面(当然是针对上面那条来说了) Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性 Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)Shift+Ctrl+Enter 在当前行插入空行(原理同上条) Ctrl+Q 定位到最后编辑的地方Ctrl+L 定位在某行 (对于程序超过100的人就有福音了)Ctrl+M 最大化当前的Edit或View (再按则反之)Ctrl+/ 注释当前行,再按则取消注释Ctrl+O 快速显示 OutLineCtrl+T 快速显示当前类的继承结构Ctrl+W 关闭当前EditerCtrl+K 参照选中的Word快速定位到下一个Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) Ctrl+/(小键盘) 折叠当前类中的所有代码 Ctrl+×(小键盘) 展开当前类中的所有代码 Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用 Alt+/来代替) Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有 ,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了) Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) Ctrl+Shift+F4 关闭所有打开的Editer Ctrl+Shift+X 把当前选中的文本全部变味小写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Ctrl+Shift+F 格式化当前代码 Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之 ) 下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开 头的了) Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力) Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能) Alt+Shift+I 合并变量(可能这样说有点不妥Inline)Alt+Shift+V 移动函数和变量(不怎么常用)Alt+Shift+Z 重构的后悔药(Undo)","categories":[{"name":"IDE","slug":"IDE","permalink":"https://xu-github.github.io/categories/IDE/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://xu-github.github.io/tags/IDE/"},{"name":"快捷键","slug":"快捷键","permalink":"https://xu-github.github.io/tags/快捷键/"}]},{"title":"【转载】java.toString() ,(String),String.valueOf的区别","slug":"java.toString","date":"2018-09-14T02:22:16.000Z","updated":"2019-04-03T12:56:01.572Z","comments":true,"path":"2018/09/14/java.toString/","link":"","permalink":"https://xu-github.github.io/2018/09/14/java.toString/","excerpt":"","text":"在java项目的实际开发和应用中，常常需要用到将对象转为String这一基本功能。本文将对常用的转换方法进行一个总结。 ​ 常用的方法有Object#toString()，（String）要转换的对象，String.valueOf(Object)等。 下面对这些方法一一进行分析。 方法1：采用 Object#toString()方法 请看下面的例子： ​ Object object = getObject(); System.out.println(object.toString()); ​ 在这种使用方法中，因为java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString（）方法。 方法2：采用类型转换（String）object方法 ​ 这是标准的类型转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。因此最好用instanceof做个类型检查，以判断是否可以转换。否则容易抛出CalssCastException异常。此外，需特别小心的是因定义为Object 类型的对象在转成String时语法检查并不会报错，这将可能导致潜在的错误存在。这时要格外小心。 如： Object obj = new Integer(100); String strVal = (String)obj; 在运行时将会出错，因为将Integer类型强制转换为String类型，无法通过。 但是， Integer obj = new Integer(100); String strVal = (String)obj; 如是格式代码，将会报语法错误。此外，因null值可以强制转换为任何java类类型，(String)null也是合法的。 方法3：采用String.valueOf(Object) ​ String.valueOf(Object)的基础是Object#toString()。但它与Object#toString()又有所不同。在前面方法1的分析中提到，使用后者时需保证不为null。但采用第三种方法时，将不用担心object是否为null值这一问题。 ​ 为了便于说明问题，我们来分析一下相关的源代码。 ​ Jdk里String# valueOf(Object)源码如下： ​ public static String valueOf(Object obj) { return (obj == null) ? “null” : obj.toString(); } ​ 从上面的源码可以很清晰的看出null值不用担心的理由。但是，这也恰恰给了我们隐患。我们应当注意到，当object为null 时，String.valueOf（object）的值是字符串”null”，而不是null！！！在使用过程中切记要注意。 ​ 试想一下，如果我们用 ​ if(String.valueOf（object）==null){System.out.println(“传入的值是null！”);}这样的语句将可能会发生什么问题。再想一下，向控制台输出时，在视觉上如下语句在执行的结果上有什么不同： System.out.println(String.valueOf(null)); System.out.println(null); 我们看到的输出将是一模一样的东西：null，但它们意义相同吗？ ​ 以上是对object对象转换为String的一些总结。 https://blog.csdn.net/springk/article/details/6414017","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"string","slug":"string","permalink":"https://xu-github.github.io/tags/string/"}]},{"title":"【转载】金额转大写（可处理千万亿，精确到分）","slug":"java-money-s","date":"2018-06-21T07:19:16.000Z","updated":"2019-04-03T13:02:42.634Z","comments":true,"path":"2018/06/21/java-money-s/","link":"","permalink":"https://xu-github.github.io/2018/06/21/java-money-s/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package org.GE.action;import java.math.BigDecimal;import java.util.HashMap;import java.util.Map;import java.util.Scanner;/** * Created with IntelliJ IDEA. * User: Administrator * Date: 14-4-12 * Time: 上午11:18 * To change this template use File | Settings | File Templates. */public class Test1&#123; public static void main(String[] args) throws Exception &#123; Scanner sc = new Scanner(System.in); while(true)&#123; System.out.print(\"请输入需要转换的数字：\"); String i = sc.nextLine(); System.out.println(digitUppercase(i)); &#125; &#125; /** * 处理的最大数字达千万亿位 精确到分 * @return */ public static String digitUppercase(String num) throws Exception&#123; String fraction[] = &#123;\"角\", \"分\"&#125;; String digit[] = &#123; \"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\" &#125;; /** * 仟 佰 拾 ' ' ' ' $4 $3 $2 $1 万 $8 $7 $6 $5 亿 $12 $11 $10 $9 */ String unit1[] = &#123;\"\", \"拾\", \"佰\", \"仟\"&#125;;//把钱数分成段,每四个一段,实际上得到的是一个二维数组 String unit2[] = &#123;\"元\", \"万\", \"亿\",\"万亿\"&#125;; //把钱数分成段,每四个一段,实际上得到的是一个二维数组 BigDecimal bigDecimal = new BigDecimal(num); bigDecimal=bigDecimal.multiply(new BigDecimal(100));// Double bigDecimal = new Double(name*100); 存在精度问题 eg：145296.8 String strVal = String.valueOf(bigDecimal.toBigInteger()); String head = strVal.substring(0,strVal.length()-2); //整数部分 String end = strVal.substring(strVal.length()-2); //小数部分 String endMoney=\"\"; String headMoney = \"\"; if(\"00\".equals(end))&#123; endMoney = \"整\"; &#125;else&#123; if(!end.substring(0,1).equals(\"0\"))&#123; endMoney+=digit[Integer.valueOf(end.substring(0,1))]+\"角\"; &#125;else if(end.substring(0,1).equals(\"0\") &amp;&amp; !end.substring(1,2).equals(\"0\"))&#123; endMoney+= \"零\"; &#125; if(!end.substring(1,2).equals(\"0\"))&#123; endMoney+=digit[Integer.valueOf(end.substring(1,2))]+\"分\"; &#125; &#125; char[] chars = head.toCharArray(); Map&lt;String,Boolean&gt; map = new HashMap&lt;String,Boolean&gt;();//段位置是否已出现zero boolean zeroKeepFlag = false;//0连续出现标志 int vidxtemp = 0; for(int i=0;i&lt;chars.length;i++)&#123; int idx = (chars.length-1-i)%4;//段内位置 unit1 int vidx = (chars.length-1-i)/4;//段位置 unit2 String s = digit[Integer.valueOf(String.valueOf(chars[i]))]; if(!\"零\".equals(s))&#123; headMoney += s +unit1[idx]+unit2[vidx]; zeroKeepFlag = false; &#125;else if(i==chars.length-1 || map.get(\"zero\"+vidx)!=null)&#123; headMoney += \"\" ; &#125;else&#123; headMoney += s; zeroKeepFlag = true; map.put(\"zero\"+vidx,true);//该段位已经出现0； &#125; if(vidxtemp!=vidx || i==chars.length-1)&#123; headMoney = headMoney.replaceAll(unit2[vidx],\"\"); headMoney+=unit2[vidx]; &#125; if(zeroKeepFlag &amp;&amp; (chars.length-1-i)%4==0)&#123; headMoney = headMoney.replaceAll(\"零\",\"\"); &#125; &#125; return headMoney+endMoney; &#125;&#125; 转自：http://605113068.iteye.com/blog/2049163","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"}]},{"title":"【转载】java金额转大写","slug":"java-money","date":"2018-06-21T07:02:16.000Z","updated":"2019-04-03T13:03:03.308Z","comments":true,"path":"2018/06/21/java-money/","link":"","permalink":"https://xu-github.github.io/2018/06/21/java-money/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250package com.b510.number2char;import java.math.BigDecimal;/** \\* 数字转换为汉语中人民币的大写&lt;br&gt; \\* \\* @author hongten \\* @contact hongtenzone@foxmail.com \\* @create 2013-08-13 */public class NumberToCN &#123; /** \\* 汉语中数字大写 */ private static final String[] CN_UPPER_NUMBER = &#123; \"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\" &#125;; /** \\* 汉语中货币单位大写，这样的设计类似于占位符 */ private static final String[] CN_UPPER_MONETRAY_UNIT = &#123; \"分\", \"角\", \"元\", \"拾\", \"佰\", \"仟\", \"万\", \"拾\", \"佰\", \"仟\", \"亿\", \"拾\", \"佰\", \"仟\", \"兆\", \"拾\", \"佰\", \"仟\" &#125;; /** \\* 特殊字符：整 */ private static final String CN_FULL = \"整\"; /** \\* 特殊字符：负 */ private static final String CN_NEGATIVE = \"负\"; /** \\* 金额的精度，默认值为2 */ private static final int MONEY_PRECISION = 2; /** \\* 特殊字符：零元整 */ private static final String CN_ZEOR_FULL = \"零元\" + CN_FULL; /** \\* 把输入的金额转换为汉语中人民币的大写 \\* \\* @param numberOfMoney \\* 输入的金额 \\* @return 对应的汉语大写 */ public static String number2CNMontrayUnit(BigDecimal numberOfMoney) &#123; StringBuffer sb = new StringBuffer(); // -1, 0, or 1 as the value of this BigDecimal is negative, zero, or // positive. int signum = numberOfMoney.signum(); // 零元整的情况 if (signum == 0) &#123; return CN_ZEOR_FULL; &#125; //这里会进行金额的四舍五入 long number = numberOfMoney.movePointRight(MONEY_PRECISION) .setScale(0, 4).abs().longValue(); // 得到小数点后两位值 long scale = number % 100; int numUnit = 0; int numIndex = 0; boolean getZero = false; // 判断最后两位数，一共有四中情况：00 = 0, 01 = 1, 10, 11 if (!(scale &gt; 0)) &#123; numIndex = 2; number = number / 100; getZero = true; &#125; if ((scale &gt; 0) &amp;&amp; (!(scale % 10 &gt; 0))) &#123; numIndex = 1; number = number / 10; getZero = true; &#125; int zeroSize = 0; while (true) &#123; if (number &lt;= 0) &#123; break; &#125; // 每次获取到最后一个数 numUnit = (int) (number % 10); if (numUnit &gt; 0) &#123; if ((numIndex == 9) &amp;&amp; (zeroSize &gt;= 3)) &#123; sb.insert(0, CN_UPPER_MONETRAY_UNIT[6]); &#125; if ((numIndex == 13) &amp;&amp; (zeroSize &gt;= 3)) &#123; sb.insert(0, CN_UPPER_MONETRAY_UNIT[10]); &#125; sb.insert(0, CN_UPPER_MONETRAY_UNIT[numIndex]); sb.insert(0, CN_UPPER_NUMBER[numUnit]); getZero = false; zeroSize = 0; &#125; else &#123; ++zeroSize; if (!(getZero)) &#123; sb.insert(0, CN_UPPER_NUMBER[numUnit]); &#125; if (numIndex == 2) &#123; if (number &gt; 0) &#123; sb.insert(0, CN_UPPER_MONETRAY_UNIT[numIndex]); &#125; &#125; else if (((numIndex - 2) % 4 == 0) &amp;&amp; (number % 1000 &gt; 0)) &#123; sb.insert(0, CN_UPPER_MONETRAY_UNIT[numIndex]); &#125; getZero = true; &#125; // 让number每次都去掉最后一个数 number = number / 10; ++numIndex; &#125; // 如果signum == -1，则说明输入的数字为负数，就在最前面追加特殊字符：负 if (signum == -1) &#123; sb.insert(0, CN_NEGATIVE); &#125; // 输入的数字小数点后两位为\"00\"的情况，则要在最后追加特殊字符：整 if (!(scale &gt; 0)) &#123; sb.append(CN_FULL); &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; double money = 2020004.01; BigDecimal numberOfMoney = new BigDecimal(money); String s = NumberToCN.number2CNMontrayUnit(numberOfMoney); System.out.println(\"你输入的金额为：【\"+ money +\"】 #--# [\" +s.toString()+\"]\"); &#125;&#125; 转自：https://www.cnblogs.com/hongten/p/hongten_java_money.html","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"}]},{"title":"【转载】iReport文字自动换行设置","slug":"iReport-word","date":"2018-05-08T07:22:16.000Z","updated":"2019-04-03T13:03:28.322Z","comments":true,"path":"2018/05/08/iReport-word/","link":"","permalink":"https://xu-github.github.io/2018/05/08/iReport-word/","excerpt":"","text":"1、 选中要自动换行的text框，勾选中属性面板中的“StretchWith Overflow”属性 2、 选中该字段所在行的所有字段（包括行头），在“属性”面板中将“Stretch Type”设置为“Relative to Tallest Object”","categories":[{"name":"ireport","slug":"ireport","permalink":"https://xu-github.github.io/categories/ireport/"}],"tags":[{"name":"ireport","slug":"ireport","permalink":"https://xu-github.github.io/tags/ireport/"}]},{"title":"【转载】for update和for update nowait的区别和使用","slug":"sql-update","date":"2018-01-03T09:22:16.000Z","updated":"2019-04-03T13:05:08.524Z","comments":true,"path":"2018/01/03/sql-update/","link":"","permalink":"https://xu-github.github.io/2018/01/03/sql-update/","excerpt":"","text":"首先，for update 和for update nowait 是对操作的数据行进行加锁，在事务提交前防止其他操作对数据的修改。 for update 和for update nowait主要区别在于是否等待，如果不加nowait，在执行select时就会报错，如果加了nowait,在执行select时就会等待，直至锁被释放。 首先我们使用两个sql:1231.select * from HH t where id='1' for update2.select * from HH t where id ='1' for update nowait sql1在pl/sql中执行，sql2在ob12中执行（在pl/sql或ob12中开两个窗口执行不行，现在我也不知道为什么）： 执行sql1后查询出正确信息，在执行sql2,出现错误信息“ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源, 或者超时失效”。这是因为执行sql1时对改行的数据加了锁，其他操作是不能访问改行的。当我们在sql1后执行commit后，sql2就能显示正确的数据。 将sql2换成for update 按上面得步骤执行，sql2会一直等待锁得释放不会，直至sql1后commit，sql2就能查询出数据； 这里还有 for update wait n (n是时间，单位：秒)，即会等待n秒，n秒之后数据还是锁住的话就会报上面提到的错误； 其实for update 就是为了防止在查询数据的时候对数据进行修改，比如有以下两个sql: sql1：select * from HH t where id=’1’ for update sql2:update HH set name=’张三’ where id = ‘1’ 当我们执行sql1后，在执行sql2，sql2就会一直等待sql1将锁释放后才能执行，这样在查询的时候就不会出行数据改变，在sql1后执行commit,sql2就会自动执行了。 转自：https://www.cnblogs.com/mouseIT/p/4174157.html","categories":[{"name":"sql","slug":"sql","permalink":"https://xu-github.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://xu-github.github.io/tags/sql/"},{"name":"update","slug":"update","permalink":"https://xu-github.github.io/tags/update/"}]},{"title":"【原创】Eclipse显示空格，换行符等","slug":"eclipse-space","date":"2018-01-02T08:22:16.000Z","updated":"2019-04-03T13:10:31.080Z","comments":true,"path":"2018/01/02/eclipse-space/","link":"","permalink":"https://xu-github.github.io/2018/01/02/eclipse-space/","excerpt":"","text":"设置如下： 选择Window-&gt;Preferences-&gt;General-&gt;Editors-&gt;Text Editors-&gt;Show whitespace characters","categories":[{"name":"eclipse","slug":"eclipse","permalink":"https://xu-github.github.io/categories/eclipse/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"https://xu-github.github.io/tags/eclipse/"}]},{"title":"【原创】JAVA中的时间大小比较","slug":"java-time-compare1","date":"2017-12-06T08:22:16.000Z","updated":"2019-04-03T13:13:41.550Z","comments":true,"path":"2017/12/06/java-time-compare1/","link":"","permalink":"https://xu-github.github.io/2017/12/06/java-time-compare1/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.text.DateFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class DateTest &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub DateFormat df = new SimpleDateFormat(\"HH:mm:ss\");//创建日期转换对象HH:mm:ss为时分秒，年月日为yyyy-MM-dd try &#123; Date dt1 = df.parse(\"15:00:00\");//将字符串转换为date类型 Date dt2 = df.parse(\"17:00:00\"); if(dt1.getTime()&gt;dt2.getTime())//比较时间大小,如果dt1大于dt2 &#123; System.out.println(\"yes\"); &#125; else &#123; System.out.println(\"no\");//运行输出no &#125; &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; ======================================================import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/**** @author hp*/public class test &#123; public static void main(String args[]) &#123; int i= compare_date(\"1995-11-12 15:21\", \"1999-12-11 09:59\"); System.out.println(\"i==\"+i); &#125; public static int compare_date(String DATE1, String DATE2) &#123; DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd hh:mm\"); try &#123; Date dt1 = df.parse(DATE1); Date dt2 = df.parse(DATE2); if (dt1.getTime() &gt; dt2.getTime()) &#123; System.out.println(\"dt1 在dt2前\"); return 1; &#125; else if (dt1.getTime() &lt; dt2.getTime()) &#123; System.out.println(\"dt1在dt2后\"); return -1; &#125; else &#123; return 0; &#125; &#125; catch (Exception exception) &#123; exception.printStackTrace(); &#125; return 0; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"时间","slug":"时间","permalink":"https://xu-github.github.io/tags/时间/"}]},{"title":"【转载】Java时间和时间戳的相互转换","slug":"java-time-compare2","date":"2017-12-06T08:22:16.000Z","updated":"2019-04-03T13:16:09.926Z","comments":true,"path":"2017/12/06/java-time-compare2/","link":"","permalink":"https://xu-github.github.io/2017/12/06/java-time-compare2/","excerpt":"","text":"时间转换为时间戳：123456789101112 /* * 将时间转换为时间戳 */ public static String dateToStamp(String s) throws ParseException&#123; String res; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date date = simpleDateFormat.parse(s); long ts = date.getTime(); res = String.valueOf(ts); return res;&#125; 时间戳转换为时间：1234567891011/* * 将时间戳转换为时间 */public static String stampToDate(String s)&#123; String res; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); long lt = new Long(s); Date date = new Date(lt); res = simpleDateFormat.format(date); return res;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"时间","slug":"时间","permalink":"https://xu-github.github.io/tags/时间/"}]},{"title":"【原创】Java 将String转化为Int","slug":"java-stringtoint","date":"2017-12-06T07:22:16.000Z","updated":"2019-04-03T13:18:33.515Z","comments":true,"path":"2017/12/06/java-stringtoint/","link":"","permalink":"https://xu-github.github.io/2017/12/06/java-stringtoint/","excerpt":"","text":"在 Java 中要将 String 类型转化为 int 类型时,需使用 Integer 类中的 parseInt() 方法或者 valueOf() 方法进行转换. 例1:123456String str = \"123\";try &#123; int a = Integer.parseInt(str);&#125; catch (NumberFormatException e) &#123; e.printStackTrace();&#125; 例2:123456String str = \"123\";try &#123; int b = Integer.valueOf(str).intValue()&#125; catch (NumberFormatException e) &#123; e.printStackTrace();&#125; 在转换过程中需注意,因为字符串中可能会出现非数字的情况,所以在转换的时候需要捕捉处理异常","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"}]},{"title":"【原创】postgresql 判断字段是否为空","slug":"postgresql-null","date":"2017-12-06T07:22:16.000Z","updated":"2019-04-03T13:19:53.494Z","comments":true,"path":"2017/12/06/postgresql-null/","link":"","permalink":"https://xu-github.github.io/2017/12/06/postgresql-null/","excerpt":"","text":"select COALESCE(tran.rm_amt,0) rm_amt select COALESCE(null, 0) as test 结果 test 0","categories":[{"name":"postgresql","slug":"postgresql","permalink":"https://xu-github.github.io/categories/postgresql/"}],"tags":[{"name":"db","slug":"db","permalink":"https://xu-github.github.io/tags/db/"},{"name":"postgresql","slug":"postgresql","permalink":"https://xu-github.github.io/tags/postgresql/"}]},{"title":"【原创】postgreSQL数据类型字符串和数值相互转换","slug":"postgreSQL-stringtoint","date":"2017-12-06T06:22:16.000Z","updated":"2019-04-03T13:27:58.659Z","comments":true,"path":"2017/12/06/postgreSQL-stringtoint/","link":"","permalink":"https://xu-github.github.io/2017/12/06/postgreSQL-stringtoint/","excerpt":"","text":"##1、将数值转成字符串类型 方法1：调用to_char(int, text)函数，int为要转换值，text为数值格式化模式，其中模式描述为：|模式| 描述||-|-||9| 带有指定数值位数的值||0| 带前导零的值||.|(句点) 小数点||,|(逗号) 分组(千)分隔符||PR| 尖括号内负值||S| 带符号的数值||L| 货币符号||D| 小数点||G| 分组分隔符||MI| 在指明的位置的负号(如果数字 &lt; 0)||PL| 在指明的位置的正号(如果数字 &gt; 0)||SG| 在指明的位置的正/负号 |使用举例：1234SELECT to_char(12345, '9999999999999999999')//结果‘ 12345’，结果字符串前面有空格，位数跟格式化模式中9的位数有关；SELECT to_char(12345, '99999')//结果‘12345’SELECT to_char(12345, '9999')//结果‘####’，当模式串小于数字个数时，字符串会显示为#，位数跟格式化模式中9的位数有关；SELECT to_char(12345, '')//结果‘’ 问题：将数值转成字符串且不要前面的空格实现起来很麻烦，由于无法判断格式化模式中9的位数。可用下面方法2解决：方法2：通过||连接‘’||12345 ##2、将字符串转成数值方法调用： to_number（text,text）函数，参数1是要转的数字字符串，参数2为模式参数,返回的类型 numeric1234567使用举例：SELECT to_number('12345', '9999999999999999999')//12345SELECT to_number('12345', '99999')//12345SELECT to_number(''||12345, '9999')//1234，由于模式是4位，结果忽略最后一位；SELECT to_number(' 12345', '9999999999999999999')//12345SELECT to_number(' ab ,1,2a3,4b5', '9999999999999999999')//12345，会忽略所有字符串中非数字字符select to_number('12,454.8-', '99G999D9S') 另外还可以12345--把'1234'转成整数select cast('1234' as integer) ;select cast('1234' as int) ;--用substring截取字符串，从第8个字符开始截取2个字符：结果是12。（索引从1开始）select cast(substring('1234abc12',8,2) as integer) 还见过以下写法1select '123456'::int test","categories":[{"name":"postgresql","slug":"postgresql","permalink":"https://xu-github.github.io/categories/postgresql/"}],"tags":[{"name":"db","slug":"db","permalink":"https://xu-github.github.io/tags/db/"},{"name":"postgresql","slug":"postgresql","permalink":"https://xu-github.github.io/tags/postgresql/"}]},{"title":"【原创】Java 抽象类","slug":"java-chouxiang-class","date":"2017-11-15T03:11:16.000Z","updated":"2019-04-03T13:35:38.462Z","comments":true,"path":"2017/11/15/java-chouxiang-class/","link":"","permalink":"https://xu-github.github.io/2017/11/15/java-chouxiang-class/","excerpt":"","text":"Java 抽象类在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 抽象方法如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。任何子类必须重写父类的抽象方法，或者声明自身为抽象类。继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 抽象类总结规定 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 更多参考：http://www.runoob.com/java/java-abstraction.html","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"}]},{"title":"【原创】Java String.split()","slug":"Java String.split","date":"2017-11-15T03:11:16.000Z","updated":"2019-04-03T13:31:10.675Z","comments":true,"path":"2017/11/15/Java String.split/","link":"","permalink":"https://xu-github.github.io/2017/11/15/Java String.split/","excerpt":"","text":"在java.lang包中有String.split()方法,返回是一个数组 在应用中用到一些,总结如下:12345678910111213141516171、用“.”分隔时,写法String.split(\"\\\\.\"),不能用String.split(\".\");2、用“|”分隔时,写法String.split(\"\\\\|\"),不能用String.split(\"|\");“.”和“|”都是转义字符,必须得加\"\\\\\";3、如果在一个字符串中有多个分隔符,可以用“|”作为连字符,比如,“acount=? and uu =? or n=?”,把三个都分隔出来,可以用String.split(\"and|or\");使用String.split方法分隔字符串时,分隔符如果用到一些特殊字符,可能会得不到我们预期的结果看jdk doc中说明 public String[] split(String regex) Splits this string around matches of the given regular expression. 参数regex是一个 regular-expression的匹配模式而不是一个简单的String。","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"}]},{"title":"【转载】Java 接口","slug":"java-interface","date":"2017-11-01T11:17:16.000Z","updated":"2019-04-03T13:34:32.531Z","comments":true,"path":"2017/11/01/java-interface/","link":"","permalink":"https://xu-github.github.io/2017/11/01/java-interface/","excerpt":"","text":"接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口与类相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 \\1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 \\2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 \\3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 \\4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口有以下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 接口的实现当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式： …implements 接口名称[, 其他接口, 其他接口…, …] … 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 接口的多继承在Java中，类的多继承是不合法，但接口允许多继承，。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 总结： 1.接口可以多继承 2.接口的方法声明必须是 public abstract 即便不写默认也是 3.接口里面不能包含方法具体实现 4.类实继承接口必须实现接口里申明的全部方法，除非该类是抽象类 5.类里面可以声明 public static final 修饰的变量 6.接口不能被实例化，但是可以被实现类创建 什么时候使用抽象类和接口 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。 更多参考：http://www.runoob.com/java/java-interfaces.html","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"}]},{"title":"【原创】Java继承","slug":"java-jicheng","date":"2017-11-01T10:11:16.000Z","updated":"2019-04-03T13:39:37.185Z","comments":true,"path":"2017/11/01/java-jicheng/","link":"","permalink":"https://xu-github.github.io/2017/11/01/java-jicheng/","excerpt":"","text":"#概念继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 ##类的继承格式在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下： 12类的继承格式class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; #特性子类拥有父类非private的属性，方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。 #关键字继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 ##extends关键字在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 ##implements关键字使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 ##super 与 this 关键字super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 ##final关键字final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final #构造器子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。 如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。 ##1、为什么使用继承 从已有的类派生出新的类，称为继承。 在不同的类中也可能会有共同的特征和动作，可以把这些共同的特征和动作放在一个类中，让其它类共享。 因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。 继承是 Java 中实现软件重用的重要手段，避免重复，易于维护，易于理解。 ##2、父类和子类 如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A， 则称类 A 为”父类”，也称为超类、基类； 称类 B 为”子类”，也称为次类、扩展类、派生类。 子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。 更多参考：http://www.runoob.com/java/java-inheritance.html","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"}]},{"title":"【原创】Java Override/Overload","slug":"Java-OverrideOverload","date":"2017-11-01T09:11:16.000Z","updated":"2019-04-03T13:44:43.645Z","comments":true,"path":"2017/11/01/Java-OverrideOverload/","link":"","permalink":"https://xu-github.github.io/2017/11/01/Java-OverrideOverload/","excerpt":"","text":"#重写(Override)重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。 ###重写规则： 参数列表必须完全与被重写方法的相同；返回类型必须完全与被重写方法的返回类型相同；访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。父类的成员方法只能被它的子类重写。声明为final的方法不能被重写。声明为static的方法不能被重写，但是能够被再次声明。子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。构造方法不能被重写。如果不能继承一个方法，则不能重写这个方法。 #重载(Overload)重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 ###重载规则 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；被重载的方法可以改变返回类型；被重载的方法可以改变访问修饰符；被重载的方法可以声明新的或更广的检查异常；方法能够在同一个类中或者在一个子类中被重载。无法以返回值类型作为重载函数的区分标准。 #区别|区别点| 重载方法| 重写方法||-|-|-||参数列表| 必须修改| 一定不能修改||返回类型| 可以修改| 一定不能修改||异常| 可以修改| 可以减少或删除，一定不能抛出新的或者更广的异常||访问| 可以修改| 一定不能做更严格的限制（可以降低限制）| #总结方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 更多参考：http://www.runoob.com/java/java-override-overload.html","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"}]},{"title":"【转载】Java 异常","slug":"Java-exception","date":"2017-10-30T10:19:16.000Z","updated":"2019-04-03T13:49:52.518Z","comments":true,"path":"2017/10/30/Java-exception/","link":"","permalink":"https://xu-github.github.io/2017/10/30/Java-exception/","excerpt":"","text":"如图可以看出所有的异常跟错误都继承与Throwable类，也就是说所有的异常都是一个对象。 从大体来分异常为两块： 1、error—错误 ： 是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。 2、Exception — 异常 ：异常可分为运行时异常跟编译异常 1）运行时异常：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。 2）编译异常：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。 3、java处理异常的机制：抛出异常以及捕获异常 ，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。 4、throw跟throws的区别: 123public void test thorws Exception()&#123; throw new Exception();&#125; 从上面这一段代码可以明显的看出两者的区别。throws表示一个方法声明可能抛出一个异常，throw表示此处抛出一个已定义的异常（可以是自定义需继承Exception，也可以是java自己给出的异常类）。 5、接下来看一下如何捕获异常： 1）首先java对于异常捕获使用的是try—catch或try — catch — finally 代码块，程序会捕获try代码块里面的代码，若捕获到异常则进行catch代码块处理。若有finally则在catch处理后执行finally里面的代码。然而存在这样两个问题： a.看如下代码： 12345678try&#123; //待捕获代码&#125;catch（Exception e）&#123; System.out.println(&quot;catch is begin&quot;); return 1 ；&#125;finally&#123; System.out.println(&quot;finally is begin&quot;);&#125; 在catch里面有一个return，那么finally会不会被执行呢？答案是肯定的，上面代码的执行结果为： 12catch is beginfinally is begin 也就是说会先执行catch里面的代码后执行finally里面的代码最后才return1 ； b.看如下代码： 123456789try&#123; //待捕获代码 &#125;catch（Exception e）&#123; System.out.println(&quot;catch is begin&quot;); return 1 ；&#125;finally&#123; System.out.println(&quot;finally is begin&quot;); return 2 ;&#125; 在b代码中输出结果跟a是一样的，然而返回的是return 2 ； 原因很明显，就是执行了finally后已经return了，所以catch里面的return不会被执行到。也就是说finally永远都会在catch的return前被执行。（这个是面试经常问到的问题哦！） 6、对于异常的捕获不应该觉得方便而将几个异常合成一个Exception进行捕获，比如有IO的异常跟SQL的异常，这样完全不同的两个异常应该分开处理！而且在catch里处理异常的时候不要简单的e.printStackTrace()，而是应该进行详细的处理。比如进行console打印详情或者进行日志记录。 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。 转自：http://www.runoob.com/java/java-exceptions.html","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"exception","slug":"exception","permalink":"https://xu-github.github.io/tags/exception/"}]},{"title":"【原创】String+StringBuilder+StringBuffer","slug":"String+StringBuilder+StringBuffer","date":"2017-10-30T09:19:16.000Z","updated":"2019-04-03T13:46:38.600Z","comments":true,"path":"2017/10/30/String+StringBuilder+StringBuffer/","link":"","permalink":"https://xu-github.github.io/2017/10/30/String+StringBuilder+StringBuffer/","excerpt":"","text":"如果需要对字符串做很多修改，那么应该选择使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuilder和StringBuffer 类的对象能够被多次的修改，长度是可变的，调用append 方法，来改变长度，不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 简而言之即： String 长度大小不可变StringBuffer 和 StringBuilder 长度可变StringBuffer 线程安全 StringBuilder 线程不安全StringBuilder 速度快","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"string","slug":"string","permalink":"https://xu-github.github.io/tags/string/"}]},{"title":"【转载】成员变量和类变量的区别","slug":"java-variable","date":"2017-10-30T07:19:16.000Z","updated":"2019-04-03T13:51:51.968Z","comments":true,"path":"2017/10/30/java-variable/","link":"","permalink":"https://xu-github.github.io/2017/10/30/java-variable/","excerpt":"","text":"#成员变量和类变量的区别 由static修饰的变量称为静态变量，其实质上就是一个全局变量。如果某个内容是被所有对象所共享，那么该内容就应该用静态修饰；没有被静态修饰的内容，其实是属于对象的特殊描述。 不同的对象的实例变量将被分配不同的内存空间， 如果类中的成员变量有类变量，那么所有对象的这个类变量都分配给相同的一处内存，改变其中一个对象的这个类变量会影响其他对象的这个类变量，也就是说对象共享类变量。 成员变量和类变量的区别： 1、两个变量的生命周期不同 ​ 成员变量随着对象的创建而存在，随着对象的回收而释放。 ​ 静态变量随着类的加载而存在，随着类的消失而消失。 2、调用方式不同 ​ 成员变量只能被对象调用。 ​ 静态变量可以被对象调用，还可以被类名调用。 3、别名不同 ​ 成员变量也称为实例变量。 ​ 静态变量也称为类变量。 4、数据存储位置不同 ​ 成员变量存储在堆内存的对象中，所以也叫对象的特有数据。 ​ 静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。 static 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。 特点： 1、想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。 2、被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。 ​ 3、静态随着类的加载而加载。而且优先于对象存在。 弊端： 1、有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。 2、静态方法只能访问静态成员，不可以访问非静态成员。 ​ 因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。 3、静态方法中不能使用this，super关键字。 ​ 因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。 什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？ 成员分两种： 1、成员变量。（数据共享时静态化） ​ 该成员变量的数据是否是所有对象都一样： ​ 如果是，那么该变量需要被静态修饰，因为是共享的数据。 ​ 如果不是，那么就说这是对象的特有数据，要存储到对象中。 2、成员函数。（方法中没有调用特有数据时就定义成静态） ​ 如果判断成员函数是否需要被静态修饰呢？ ​ 只要参考，该函数内是否访问了对象中的特有数据： ​ 如果有访问特有数据，那方法不能被静态修饰。 ​ 如果没有访问过特有数据，那么这个方法需要被静态修饰。 #成员变量和静态变量的区别： 1、成员变量所属于对象。所以也称为实例变量。 ​ 静态变量所属于类。所以也称为类变量。 2、成员变量存在于堆内存中。 ​ 静态变量存在于方法区中。 3、成员变量随着对象创建而存在。随着对象被回收而消失。 ​ 静态变量随着类的加载而存在。随着类的消失而消失。 4、成员变量只能被对象所调用 。 ​ 静态变量可以被对象调用，也可以被类名调用。 所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。 转自：http://www.runoob.com/java/java-object-classes.html","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"变量","slug":"变量","permalink":"https://xu-github.github.io/tags/变量/"}]},{"title":"【原创】Java中List集合去重（二）","slug":"java-list2","date":"2017-10-27T05:22:16.000Z","updated":"2019-04-03T13:56:08.581Z","comments":true,"path":"2017/10/27/java-list2/","link":"","permalink":"https://xu-github.github.io/2017/10/27/java-list2/","excerpt":"","text":"关于List中对象去重，如果List中存储的数据类型是基本数据类型，可直接将list集合转换成set集合，或采用其他方法，上篇有陈述。本篇说下list集合中的数据类型是一个对象类型的情况，需要在对象的实体类中去重写equals()方法和hashCode()方法。 在该例中，我们将User实体类中用户编码和姓名作为判断该对象重复的标识，在User实体类中我们重写这两个方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class User &#123;private int id;private String userCd;private String userNm;private String phone;private String memo;public User(int id, String userCd, String userNm, String phone, String memo) &#123;super();this.id = id;this.userCd = userCd;this.userNm = userNm;this.phone = phone;this.memo = memo;&#125;public int getId() &#123;return id;&#125;public void setId(int id) &#123;this.id = id;&#125;public String getUserCd() &#123;return userCd;&#125;public void setUserCd(String userCd) &#123;this.userCd = userCd;&#125;public String getUserNm() &#123;return userNm;&#125;public void setUserNm(String userNm) &#123;this.userNm = userNm;&#125;public String getPhone() &#123;return phone;&#125;public void setPhone(String phone) &#123;this.phone = phone;&#125;public String getMemo() &#123;return memo;&#125;public void setMemo(String memo) &#123;this.memo = memo;&#125;@Overridepublic boolean equals(Object arg0) &#123;User u = (User) arg0;return userCd.equals(u.userCd) &amp;&amp; userNm.equals(u.userNm);&#125;@Overridepublic int hashCode() &#123;String str = userCd + userNm;return str.hashCode();&#125;&#125; 以上实体类中，我们在equals()方法中取出该对象的userCd和userNm这两个属性值去判断比较，然后在重写的hashCode()方法中返回这两个属性值得hashCode值。 123456789101112131415161718192021222324252627282930313233343536package xuGroup.xuArtifact;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;public class Test2 &#123;public static void main(String[] args) &#123;// TODO Auto-generated method stubList&lt;User&gt; userList = new ArrayList&lt;User&gt;();userList.add(new User(1, \"001\", \"张三\", \"13355556666\", \"前端\"));userList.add(new User(2, \"002\", \"张三\", \"15522223333\", \"前端\"));userList.add(new User(3, \"003\", \"李四\", \"13355556666\", \"后端\"));userList.add(new User(4, \"004\", \"王五\", \"13311112222\", \"总监\"));userList.add(new User(5, \"002\", \"张三\", \"13355556666\", \"设计\"));Set&lt;User&gt; setData = new HashSet&lt;User&gt;();setData.addAll(userList);System.out.println(\"list- size----\" + userList.size());System.out.println(\"list-----\" + userList.toString());System.out.println(\"set- size----\" + setData.size());System.out.println(\"set-----\" + setData.toString());for (User pp : setData) &#123;System.out.println(\"p--\" + pp.toString());&#125;&#125;&#125; 一般情况下我们重写equals()方法的时候都要去重写hashCode()方法， String类中的equals()方法的源码如下, 通过观察equals()方法的源码我们可以看出，该方法去比较两个对象时，首先先去判断两个对象是否具有相同的地址，如果是同一个对象的引用，则直接放回true；如果地址不一样，则证明不是引用同一个对象，接下来就是挨个去比较两个字符串对象的内容是否一致，完全相等返回true，否则false。 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125; &#125; return false; &#125; String类中hashCode()方法的源码如下，在Object类中的hashCode()方法是返回对象的32位JVM内存地址，也就是说如果我们不去重写该方法，将会返回该对象的32位JVM内存地址。 1234567891011121314public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; count &gt; 0) &#123; int off = offset; char val[] = value; int len = count; for (int i = 0; i &lt; len; i++) &#123; h = 31*h + val[off++]; &#125; hash = h; &#125; return h; &#125; 这个测试的例子中，当注释重写的hashCode()方法时，这时默认返回对象的32JVM中的地址，两个不同的对象地址显然是不同的，我们在比较时，虽然通过重写的equals()方法比较出来userCd和userNm值是相同的，但是默认的hashCode()方法返回的值他们并不是同一个对象，所以我们通常要将hashCode()方法与equals()方法一起重写，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。​ 摘抄一句，用白话说，通过hashCode判断对象是否放在同一个桶里，然后再通过equals方法去判断这个桶里的对象是不是相同的，这个比喻是否挺形象，哈哈。 更多可参考： http://blog.csdn.net/fenglibing/article/details/8905007","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"List","slug":"List","permalink":"https://xu-github.github.io/tags/List/"}]},{"title":"【原创】Java中List集合去重（一）","slug":"java-list1","date":"2017-10-27T03:22:16.000Z","updated":"2019-04-03T13:59:50.238Z","comments":true,"path":"2017/10/27/java-list1/","link":"","permalink":"https://xu-github.github.io/2017/10/27/java-list1/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.test;import java.util.*;public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"111\"); list.add(\"222\"); list.add(\"222\"); list.add(\"333\"); list.add(\"333\"); list.add(\"333\"); list.add(\"444\"); new Test().removeDuplicateWithOrder(list); System.out.println(list); &#125; // 法一： 删除ArrayList中重复元素 public static void removeDuplicate(List list) &#123; for (int i = 0; i &lt; list.size() - 1; i++) &#123; for (int j = list.size() - 1; j &gt; i; j--) &#123; if (list.get(j).equals(list.get(i))) &#123; list.remove(j); &#125; &#125; &#125; System.out.println(list); &#125; // 法二：通过HashSet剔除，add后顺序会变 public static void removeDuplicate1(List list) &#123; HashSet h = new HashSet(list); list.clear(); list.addAll(h); System.out.println(list); &#125; // 法三： 删除ArrayList中重复元素，保持顺序 public static void removeDuplicateWithOrder(List list) &#123; Set set = new HashSet(); List newList = new ArrayList(); for (Iterator iter = list.iterator(); iter.hasNext();) &#123; Object element = iter.next(); if (set.add(element)) newList.add(element); &#125; list.clear(); list.addAll(newList); System.out.println(\" remove duplicate \" + list); &#125; // 法四：创建新的list，顺序保持 public static List &lt;String&gt; getNewList(List&lt;String&gt; li)&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;();//创建新的list for(int i=0; i&lt;li.size(); i++)&#123; String str = li.get(i); //获取传入集合对象的每一个元素 if(!list.contains(str))&#123; //查看新集合中是否有指定的元素，如果没有则加入 list.add(str); &#125; &#125; return list; &#125; // 法五：创建新的list，顺序保持 public static List &lt;String&gt; getNewList2(List&lt;String&gt; arr) &#123; ArrayList&lt;String&gt; newList = new ArrayList&lt;String&gt;(); for (Object s : arr) &#123; if (Collections.frequency(result, s)&lt;1) newList.add((String) s); &#125; return newList; &#125;&#125; 针对方法getList的小说明：1234frequency(Collection&lt;?&gt;, Object) 方法用于获取所指定元素集合collection等于指定对象object中的数量。if (Collections.frequency(result, s)&lt;1) result.add((String) s); 如果对象s在集合result中出现的次数小于1（无s元素），就将它添加进入集合result","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"List","slug":"List","permalink":"https://xu-github.github.io/tags/List/"}]},{"title":"【原创】Java的八种基本类型：（按字节来分）","slug":"java-type","date":"2017-10-24T02:22:16.000Z","updated":"2019-04-03T14:03:55.361Z","comments":true,"path":"2017/10/24/java-type/","link":"","permalink":"https://xu-github.github.io/2017/10/24/java-type/","excerpt":"","text":"Java的八种基本类型：（按字节来分） boolean 布尔型 1个字节 8bit（8位） byte 字节类型 1个字节 char 字符类型 2个字节 short 短整型 2个字节 int 整型 4个字节 float 浮点型（单精度）4个字节 long 长整型 8个字节 double 双精度类型 8个字节 Java中默认的整数类型是int，如果要定义为long ，则要在数值后加上L或者l 默认的浮点型是双精度浮点，如果要定义float，则要在数值后面加上f或者F 一个字节等于8位，1个字节等于256个数。2^8 一个英文字母或者阿拉伯数字占一个字节 一个汉字占2个字节","categories":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xu-github.github.io/tags/java/"},{"name":"type","slug":"type","permalink":"https://xu-github.github.io/tags/type/"}]},{"title":"【原创】ireport报表报错：Error evaluating expression","slug":"ireport-error","date":"2017-10-20T07:40:16.000Z","updated":"2019-04-03T14:05:37.887Z","comments":true,"path":"2017/10/20/ireport-error/","link":"","permalink":"https://xu-github.github.io/2017/10/20/ireport-error/","excerpt":"","text":"报错信息： Error evaluating expression : Source text : 定金收据 …… Caused by: groovy.lang.MissingPropertyException: No such property: 金收据 for class: report_test_1508483943865_782998 …… 解决： 使用组件问题 本来应该是一个静态的static Text,文本为：定金收据用了一个text Field,然后打印时，bean里面没有“定金收据”这个字段的GET方法","categories":[{"name":"ireport","slug":"ireport","permalink":"https://xu-github.github.io/categories/ireport/"}],"tags":[{"name":"ireport","slug":"ireport","permalink":"https://xu-github.github.io/tags/ireport/"}]},{"title":"【原创】ireport报表当前页及总页数","slug":"ireport-pagenum","date":"2017-10-20T04:40:16.000Z","updated":"2019-04-03T14:06:53.597Z","comments":true,"path":"2017/10/20/ireport-pagenum/","link":"","permalink":"https://xu-github.github.io/2017/10/20/ireport-pagenum/","excerpt":"","text":"报表要取得当前页/总页，在ireport的变量里面有一个$V{PAGE_NUMBER},直接拖到报表上，设置属性，Evaluation Time选择Now时，表示当前页数（”第”+$V{PAGE_NUMBER}+”页，”），选择Report时，表示总页数（”共”+$V{PAGE_NUMBER}+”页”），选择Group时，表示按组分类当前组总页数（”共”+$V{PAGE_NUMBER}+”页”）。","categories":[{"name":"ireport","slug":"ireport","permalink":"https://xu-github.github.io/categories/ireport/"}],"tags":[{"name":"ireport","slug":"ireport","permalink":"https://xu-github.github.io/tags/ireport/"}]},{"title":"【原创】sql之left join、right join、inner join的区别","slug":"sql-join","date":"2017-10-20T04:40:16.000Z","updated":"2019-04-03T14:09:48.254Z","comments":true,"path":"2017/10/20/sql-join/","link":"","permalink":"https://xu-github.github.io/2017/10/20/sql-join/","excerpt":"","text":"sql之left join、right join、inner join的区别left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录inner join(等值连接) 只返回两个表中联结字段相等的行 举例如下： 表A记录如下：aID aNum1 a12 a23 a34 a45 a5 表B记录如下:bID bName1 b12 b23 b34 b48 b8 1.left joinsql语句如下:select * from Aleft join Bon A.aID = B.bID 结果如下:aID aNum bID bName1 a1 1 b12 a2 2 b23 a3 3 b34 a4 4 b45 a5 NULL NULL （所影响的行数为 5 行）结果说明:left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的.换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID). B表记录不足的地方均为NULL.2.right joinsql语句如下:select * from Aright join Bon A.aID = B.bID 结果如下:aID aNum bID bName1 a1 1 b12 a2 2 b23 a3 3 b34 a4 4 b4NULL NULL 8 b8 （所影响的行数为 5 行）结果说明: 仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.3.inner joinsql语句如下:select * from Ainnerjoin Bon A.aID = B.bID 结果如下:aID aNum bID bName1 a1 1 b12 a2 2 b23 a3 3 b34 a4 4 b4 结果说明: 很明显,这里只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录.注:LEFT JOIN操作用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，即使在第二个（右边）表中并没有相符值的记录。 语法：FROM table1 LEFT JOIN table2 ON table1.field1 compopr table2.field2 说明：table1, table2参数用于指定要将记录组合的表的名称。field1, field2参数指定被联接的字段的名称。且这些字段必须有相同的数据类型及包含相同类型的数据，但它们不需要有相同的名称。compopr参数指定关系比较运算符：”=”， “&lt;”， “&gt;”， “&lt;=”， “&gt;=” 或 “&lt;&gt;”。如果在INNER JOIN操作中要联接包含Memo 数据类型或 OLE Object 数据类型数据的字段，将会发生错误. 另附一张图，相信对jion的操作会更加明白。","categories":[{"name":"sql","slug":"sql","permalink":"https://xu-github.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://xu-github.github.io/tags/sql/"},{"name":"db","slug":"db","permalink":"https://xu-github.github.io/tags/db/"},{"name":"join","slug":"join","permalink":"https://xu-github.github.io/tags/join/"}]},{"title":"【原创】GIT相关","slug":"git-about","date":"2017-10-11T03:40:16.000Z","updated":"2019-04-03T14:12:55.837Z","comments":true,"path":"2017/10/11/git-about/","link":"","permalink":"https://xu-github.github.io/2017/10/11/git-about/","excerpt":"","text":"工作区、暂存区、版本库 git addgit commitgit statuscat readme.txtgit reset –hard HEAD^git checkout – readme.txt注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。rm b.txt 删除 Git基本常用命令如下： mkdir： XX (创建一个空目录 XX指目录名) pwd： 显示当前目录的路径。 git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。 git add XX 把xx文件添加到暂存区去。 git commit –m “XX” 提交文件 –m 后面的是注释。 git status 查看仓库状态 git diff XX 查看XX文件修改了那些内容 git log 查看历史记录 git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本 (如果想回退到100个版本，使用git reset –hard HEAD~100 ) cat XX 查看XX文件内容 git reflog 查看历史记录的版本号id git checkout – XX 把XX文件在工作区的修改全部撤销。 git rm XX 删除XX文件 git remote add origin https://github.com/tugenhua0707/testgit 关联一个远程库 git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库 git clone https://github.com/tugenhua0707/testgit 从远程库中克隆 git checkout –b dev 创建dev分支 并切换到dev分支上 git branch 查看当前所有的分支 git checkout master 切换回master分支 git merge dev 在当前的分支上合并dev分支 git branch –d dev 删除dev分支 git branch name 创建分支 git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash list 查看所有被隐藏的文件列表 git stash apply 恢复被隐藏的文件，但是内容不删除 git stash drop 删除文件 git stash pop 恢复文件的同时 也删除文件 git remote 查看远程库的信息 git remote –v 查看远程库的详细信息 git push origin master Git会把master分支推送到远程库对应的远程分支上","categories":[{"name":"git","slug":"git","permalink":"https://xu-github.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://xu-github.github.io/tags/git/"}]},{"title":"【原创】redis相关","slug":"redis-about","date":"2017-10-11T03:40:16.000Z","updated":"2019-04-03T14:14:50.866Z","comments":true,"path":"2017/10/11/redis-about/","link":"","permalink":"https://xu-github.github.io/2017/10/11/redis-about/","excerpt":"","text":"Redis是一个key-value存储系统。Redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用 Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset--有序集合)和hash（哈希类型）。这些数据类型支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从复制）。 ##Memcache与Redis区别 Memcache提供的数据类型少，只有键值对，Redis提供的数据类型相对较多Memcache关机就没了，数据全部存到内存当中，但是没有提供故障恢复，Redis可以将数据存储到磁盘中redis提供主从复制，Memcache无Memcache是多线程的（使用协议解决的），redis是单线程","categories":[{"name":"redis","slug":"redis","permalink":"https://xu-github.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://xu-github.github.io/tags/redis/"}]},{"title":"【转载】jetty和tomcat区别与应用场景","slug":"jetty-tomcat","date":"2017-10-11T03:30:16.000Z","updated":"2019-04-03T14:18:24.774Z","comments":true,"path":"2017/10/11/jetty-tomcat/","link":"","permalink":"https://xu-github.github.io/2017/10/11/jetty-tomcat/","excerpt":"","text":"参考来源：http://www.open-open.com/lib/view/open1322622094390.html Jetty更满足公有云的分布式环境的需求，而Tomcat更符合企业级环境 Jetty更符合GAE(Google App Engine, 是 Google 管理的数据中心中用于 WEB 应用程序的开发和托管的平台) 的需求, 即云环境的需求，亦分布式环境的需求。 1）Jetty更轻量级。这是相对Tomcat而言的。 ​ 由于Tomcat除了遵循Java Servlet规范之外，自身还扩展了大量JEE特性以满足企业级应用的需求，所以Tomcat是较重量级的，而且配置较Jetty亦复杂许多。但对于大量普通互联网应用而言，并不需要用到Tomcat其他高级特性，所以在这种情况下，使用Tomcat是很浪费资源的。这种劣势放在分布式环境下，更是明显。换成Jetty，每个应用服务器省下那几兆内存，对于大的分布式环境则是节省大量资源。而且，Jetty的轻量级也使其在处理高并发细粒度请求的场景下显得更快速高效。 2）当支持大规模企业级应用时，Jetty也许便需要扩展，在这场景下Tomcat便是更优的。 所以，合适的选择应该为：云平台本身的门户网站放在Tomcat内，而云台托管的Java Web应该是部署在Jetty内的。","categories":[{"name":"base","slug":"base","permalink":"https://xu-github.github.io/categories/base/"}],"tags":[{"name":"jetty","slug":"jetty","permalink":"https://xu-github.github.io/tags/jetty/"},{"name":"tomcat","slug":"tomcat","permalink":"https://xu-github.github.io/tags/tomcat/"}]},{"title":"【转载】zookeeper和dubbo","slug":"zk-dubbo","date":"2017-10-11T01:30:16.000Z","updated":"2019-04-03T14:17:11.453Z","comments":true,"path":"2017/10/11/zk-dubbo/","link":"","permalink":"https://xu-github.github.io/2017/10/11/zk-dubbo/","excerpt":"","text":"Dubbo建议使用Zookeeper作为服务的注册中心。 Zookeeper的作用： zookeeper用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。当然也可以通过硬编码的方式把这种对应关系在调用方业务代码中实现，但是如果提供服务的机器挂掉调用者无法知晓，如果不更改代码会继续请求挂掉的机器提供服务。zookeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的ip和服务对应关系从列表中删除。至于支持高并发，简单来说就是横向扩展，在不更改代码的情况通过添加机器来提高运算能力。通过添加新的机器向zookeeper注册服务，服务的提供者多了能服务的客户就多了。 dubbo： 是管理中间层的工具，在业务层到数据仓库间有非常多服务的接入和服务提供者需要调度，dubbo提供一个框架解决这个问题。 注意这里的dubbo只是一个框架，至于你架子上放什么是完全取决于你的，就像一个汽车骨架，你需要配你的轮子引擎。这个框架中要完成调度必须要有一个分布式的注册中心，储存所有服务的元数据，你可以用zk，也可以用别的，只是大家都用zk。 zookeeper和dubbo的关系： Dubbo的将注册中心进行抽象，是得它可以外接不同的存储媒介给注册中心提供服务，有ZooKeeper，Memcached，Redis等。 引入了ZooKeeper作为存储媒介，也就把ZooKeeper的特性引进来。首先是负载均衡，单注册中心的承载能力是有限的，在流量达到一定程度的时候就需要分流，负载均衡就是为了分流而存在的，一个ZooKeeper群配合相应的Web应用就可以很容易达到负载均衡；资源同步，单单有负载均衡还不够，节点之间的数据和资源需要同步，ZooKeeper集群就天然具备有这样的功能；命名服务，将树状结构用于维护全局的服务地址列表，服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。其他特性还有Mast选举，分布式锁等。 本文转载自：http://blog.csdn.net/daiqinge/article/details/51282874","categories":[{"name":"base","slug":"base","permalink":"https://xu-github.github.io/categories/base/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://xu-github.github.io/tags/zookeeper/"},{"name":"dubbo","slug":"dubbo","permalink":"https://xu-github.github.io/tags/dubbo/"}]}]}